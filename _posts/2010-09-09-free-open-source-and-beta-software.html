---
layout: post
title: Free, Open Source and BETA Software
date: 2010-09-09 17:15:32.000000000 +01:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- Technology
tags: []
meta:
  dsq_thread_id: '563614168'
  blr_date: '2011-10-17'
  _jetpack_related_posts_cache: a:1:{s:32:"8f6677c9d6b0f903e98ad32ec61f8deb";a:2:{s:7:"expires";i:1451340203;s:7:"payload";a:3:{i:0;a:1:{s:2:"id";i:22;}i:1;a:1:{s:2:"id";i:151;}i:2;a:1:{s:2:"id";i:272;}}}}
author:
  login: andy
  email: andy@zrmt.com
  display_name: andylockran
  first_name: Andy
  last_name: Loughran
---
<p>One of the things that I'm beginning to notice about working in a software world, is that it rarely work like it's designed, and when it finally does work, it's probably not quite like how it was initially designed anyway. &nbsp;Having tried to hone my skills at programming, it was this little process that kept pushing me back.</p>
<ul>
<li><span style="line-height: 20px;">Write program1</span></li>
<li><span style="line-height: 20px;">Run program1</span></li>
<li><span style="line-height: 20px;">Write program2</span></li>
<li><span style="line-height: 20px;">Realise program1 was pants</span></li>
<li><span style="line-height: 20px;">Rewrite program1</span></li>
<li><span style="line-height: 20px;">Realise program2 was pants</span></li>
</ul>
<p>Anyhow, without realising, you end up at a stage where it doesn't make sense to keep improving your program. &nbsp;Even if it's well within your newfound abilities on writing your next program.&nbsp;</p>
<p>However, this doesn't just apply to individuals, but groups too - and not programs, but features.</p>
<p>Each time a feature is improved it inadvertently gets more complex, then it gets improved more, and more complex, and it gets to a stage where because the initial feature was so simple, that having to read the documentation to do the initial feature is more hassle than just writing out the feature in code, rather than using the library feature.</p>
<p>One of the reasons I believe that the commandline is still going strong after so many years is because it immediately puts a barrier on 'information overload' - sure there are commands which have more flags on them than a the UN headquarters, but other commands have been kept simple.</p>
<p>The other thing that I'm seeing a pattern to, is of is balancing customer expectation.</p>
<p>Google went through a period of releasing all their new software with a BETA tag. &nbsp;Aye, you may say that was just a marketing ploy - but it worked. &nbsp;It was free, it was marked 'not quite stable' and for most of us, it still 'just worked.' &nbsp;Now, compare that to Microsoft 95 when it came out - bells and whistles, CEO announcing that it was the 'future of computing' for us all - only to be followed up by a Blue Screen of Death? &nbsp;So what's changed in the last 15+ years?</p>
<p>Well, we've got from thinking that because computers are binary, they're either right or wrong. &nbsp;I remember someone saying to me once that it was 'impossible to delete a file,' - why? &nbsp;<strong>because there is no chemical reaction, only physical reactions, and physical reactions are reversible.</strong></p>
<p>Though many of us may have a laugh at that now, and run for our nearest copy of DBAN to render our harddrives unreadable (or grabbing the nearest hammer, as is the practice at one of my clients) - it's the way people thought. &nbsp;Now people are moving onto say well, Google's not always right, therefore computers aren't always right. &nbsp;Though that may be flawed logic - the conclusions are the same - computers don't always get the answer right. &nbsp;They're even building a new chip based upon 'probability' rather than AND, OR and XOR. &nbsp;How's that going to change computing?</p>
<p>With all these users now getting&nbsp;lackadaisical about the stability and correctness of their computer, people aren't too fussed if their software doesn't work. &nbsp;The majority of the time they've not paid for it, having probably downloaded it (illegally in many cases) - and in other cases have had it supplied by someone else. &nbsp;It doesn't matter if it doesn't work just right. &nbsp;Which brings me full circle.</p>
<p>If someone does pay for software and wants it delivered - they often require it to be correct first time - but how feasible is that given the new complexities of computing.</p>
<p>Discuss.</p>
